핵심 개념

1. bfs 알고리즘을 활용하여 연결된 land들을 탐색하고 이들의 갯수를 계산합니다.

풀이 과정
    1. 방문 여부를 체크하기 위한 배열을 생성합니다
    let visited : boolean[][] = []

    for (let i = 0; i < graph.length; i++) {
        visited[i] = new Array(graph[i].length).fill(false);
    }

    2. 근접한 land를 탐색하기 위한 이동 배열을 생성합니다
    const move : number[][] = [
        [1,0], [-1,0], [0,1], [0,-1], 
        [1,1], [1,-1], [-1,1], [-1,-1]
    ]

    3. 
    for (let i = 0; i<graph.length; i++){
        for (let j =0; j<graph[0].length; j++){

            4. 아직 방문하지 않았고, land에 해당하면, 큐에 넣어줍니다.
            if(graph[i][j]==1 && !visited[i][j]){
                const queue : number[][] = []
                queue.push([i,j])
                visited[i][j] = true
                answer+=1
                while(queue.length){
                    const cur = queue.pop()
                    if(!cur){
                        break
                    }
                    const ci : number = cur[0]
                    const cj : number = cur[1]
                    for (const mo of move){
                        
                        5. 큐에서 원소를 하나씩 꺼내 주변에 land가 있는지 확인하고
                        있으면 큐에 추가로 넣어줍니다.
                        const ni : number = ci+mo[0]
                        const nj : number = cj+mo[1]
                        if( 0<=ni && ni<graph.length 
                            && 0<=nj && nj<graph[0].length
                            && !visited[ni][nj] && graph[ni][nj] == 1
                        ){
                            visited[ni][nj] = true
                            queue.push([ni,nj])
                        }
                    }
                }

            }
        }
    }


